import { useScrollRestoration } from '@modern-kit/react';
import { useState, useEffect } from 'react';

# useScrollRestoration

브라우저 또는 특정 엘리먼트의 이전 스크롤 위치를 저장하고 복원하는 커스텀 훅입니다.

기본적으로 window의 스크롤을 관리하며, `ref`를 사용하여 특정 스크롤 영역을 관리할 수 있습니다.

<br />

## Code
[🔗 실제 구현 코드 확인](https://github.com/modern-agile-team/modern-kit/blob/main/packages/react/src/hooks/useScrollRestoration/index.ts)

<br />

## Interface
```ts title="typescript"
interface UseScrollRestorationOptions {
  id?: string;
  enabled?: boolean;
  behavior?: ScrollOptions['behavior'];
  retry?: number;
  maxEntries?: number;
}

function useScrollRestoration<T extends HTMLElement>({
  id,
  enabled,
  behavior,
}?: UseScrollRestorationOptions): {
  ref: React.RefObject<T>;
};
```

<br />

### Options

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `id` | `string` | `'window'` 또는 `'element'` | 스크롤 복원 식별자 (다중 인스턴스 사용 시 필수)|
| `enabled` | `boolean` | `true` | 스크롤 복원 활성화 여부 |
| `behavior` | `ScrollOptions['behavior']` | `'instant'` | 스크롤 복원 동작 방식 (`'auto'`, `'instant'`, `'smooth'`) |
| `retry` | `number` | `5` | 스크롤 복원 재시도 횟수 (지수 백오프 적용) |

<br />

## Remarks

:::caution 주의사항
- 콘텐츠가 비동기적으로 로드되는 경우 혹은 이미지 로드로 인해 저장된 스크롤 위치보다 페이지 높이가 작을 수 있습니다.
  - 이런 경우 자동으로 재시도하며, `지수 백오프(exponential backoff)` 방식으로 재시도 간격이 증가합니다.
  - 재시도 간격: 100ms → 200ms → 400ms → 800ms → 1600ms
  - 기본 최대 재시도 횟수는 `5회`이며, `retry` 옵션으로 조정할 수 있습니다.
- 한 컴포넌트 내에서 여러 번 훅을 사용할 경우, 각 인스턴스를 구분하려면 `id` 옵션을 명시적으로 부여하세요.
  - 별도의 `id`를 지정하지 않으면, `ref`가 있는 경우 `'element'`, 없는 경우는 `'window'`로 기본값이 설정됩니다.
  - id를 부여하지 않은 경우, `중복 key`로 인해 스크롤 복원 동작이 정상적으로 동작하지 않을 수 있으니 주의가 필요합니다.
- 스크롤 위치 저장은 `새로고침`, `페이지 이동(뒤로/앞으로가기)`, `훅의 언마운트` 시점에 이루어집니다.
  - 따라서, 컴포넌트가 언마운트되지 않고 유지되는 구조에서 해당 훅을 호출 시 스크롤 복원 동작이 정상적으로 동작하지 않을 수 있으니 주의가 필요합니다. (예: Layout 컴포넌트)
- URL에 `hash fragment(#section)`가 있는 경우 스크롤 복원을 하지 않습니다.
  - 이는 hash 스크롤이라는 명확한 사용자 의도를 존중하고, 브라우저의 표준 동작과 충돌을 방지하기 위함입니다.
:::

<br />

## Usage

### Window Scroll

```tsx title="typescript"
import { useScrollRestoration } from '@modern-kit/react';

const Page = () => {
  useScrollRestoration();

  return (
    <div>
      {/* 긴 컨텐츠... */}
    </div>
  );
};
```

<br />

### Specific Element

```tsx title="typescript"
import { useScrollRestoration } from '@modern-kit/react';

const ScrollBox = () => {
  const { ref } = useScrollRestoration<HTMLDivElement>();

  return (
    <div 
      ref={ref} 
      style={{ height: '500px', overflowY: 'auto' }}
    >
      {/* 내부 스크롤이 발생하는 컨텐츠 */}
    </div>
  );
};
```

<br />

### Multiple Instances

한 컴포넌트에서 여러 스크롤 영역을 관리할 때는 `id`를 명시적으로 부여해야 합니다.

```tsx title="typescript"
import { useScrollRestoration } from '@modern-kit/react';

const MultiScrollPage = () => {
  useScrollRestoration(); // window 스크롤 (기본 id: 'window')
  const { ref: sidebarRef } = useScrollRestoration<HTMLDivElement>({ id: 'sidebar' });
  const { ref: contentRef } = useScrollRestoration<HTMLDivElement>({ id: 'content' });

  return (
    <div>
      <aside ref={sidebarRef} style={{ height: '100vh', overflowY: 'auto' }}>
        {/* 사이드바 컨텐츠 */}
      </aside>
      <main ref={contentRef} style={{ height: '100vh', overflowY: 'auto' }}>
        {/* 메인 컨텐츠 */}
      </main>
    </div>
  );
};
```

<br />

### Example1

export const Example1 = () => {
  const { ref } = useScrollRestoration({ id: 'example1', behavior: 'smooth' }); 

  return (
    <div>
      <p>1. 아래 파란 박스 안에서 <strong>스크롤을 중간쯤 내리세요.</strong></p>
      <p>2. 브라우저의 <strong>'뒤로 가기'</strong> 버튼을 누르세요.</p>
      <p>3. 스크롤 위치가 유지되어 있는지 확인하세요.</p>

      <div 
        ref={ref} 
        style={{ 
          height: '300px',      
          overflowY: 'scroll',   
          border: '2px solid #333', 
          padding: '20px',
          borderRadius: '8px'
        }}
      >
       
        {Array.from({ length: 20 }, (_, i) => i).map((i) => (
          <div 
            key={i} 
            style={{ 
              height: '80px', 
              background: i % 2 === 0 ? '#e0e7ff' : '#f3f4f6',
              marginBottom: '10px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            데이터 {i + 1}
          </div>
        ))}
      </div>
    </div>
  );
};

<Example1 />

<br />

### Example2 (데이터 로딩 후 스크롤 위치 복원)

export const Example2 = () => {
  const { ref } = useScrollRestoration({ id: 'example2', behavior: 'smooth' }); 

  const [list, setList] = useState([]);

  useEffect(() => {
    setTimeout(() => {
      setList(Array.from({ length: 20 }, (_, i) => i));
    }, 1000)
  }, []);

  return (
    <div>
      <p>1. 아래 파란 박스 안에서 <strong>스크롤을 중간쯤 내리세요.</strong></p>
      <p>2. 브라우저의 <strong>'뒤로 가기'</strong> 버튼을 누르세요.</p>
      <p>3. 스크롤 위치가 유지되어 있는지 확인하세요.</p>

      <div 
        ref={ref} 
        style={{ 
          height: '300px',      
          overflowY: 'scroll',   
          border: '2px solid #333', 
          padding: '20px',
          borderRadius: '8px'
        }}
      >
       
        {list.map((i) => (
          <div 
            key={i} 
            style={{ 
              height: '80px', 
              background: i % 2 === 0 ? '#e0e7ff' : '#f3f4f6',
              marginBottom: '10px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            데이터 {i + 1}
          </div>
        ))}
      </div>
    </div>
  );
};

<Example2 />

<br />

### Example3 (다중 인스턴스 사용)

export const Example3 = () => {
  const { ref: sidebarRef } = useScrollRestoration({ id: 'sidebar', behavior: 'smooth' }); 
  const { ref: contentRef } = useScrollRestoration({ id: 'content', behavior: 'smooth' });

  return (
    <div>
      <p>1. 아래 파란 박스 안에서 <strong>스크롤을 중간쯤 내리세요.</strong></p>
      <p>2. 브라우저의 <strong>'뒤로 가기'</strong> 버튼을 누르세요.</p>
      <p>3. 스크롤 위치가 유지되어 있는지 확인하세요.</p>

      <div 
        ref={contentRef} 
        style={{ 
          height: '300px',      
          overflowY: 'scroll',   
          border: '2px solid #333', 
          padding: '20px',
          borderRadius: '8px'
        }}
      >
       
        {Array.from({ length: 20 }, (_, i) => i).map((i) => (
          <div 
            key={i} 
            style={{ 
              height: '80px', 
              background: i % 2 === 0 ? '#e0e7ff' : '#f3f4f6',
              marginBottom: '10px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            데이터(1번째 영역) {i + 1}
          </div>
        ))}
      </div>

      <br />

      <div 
        ref={sidebarRef} 
        style={{ 
          height: '300px',      
          overflowY: 'scroll',   
          border: '2px solid #333', 
          padding: '20px',
          borderRadius: '8px'
        }}
      >
       
        {Array.from({ length: 20 }, (_, i) => i).map((i) => (
          <div 
            key={i} 
            style={{ 
              height: '80px', 
              background: i % 2 === 0 ? '#bbf7d0' : '#fef9c3',
              marginBottom: '10px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            데이터(2번째 영역) {i + 1}
          </div>
        ))}
      </div>
    </div>
  );
};

<Example3 />